<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=fpjTOVmNbO4Lz34iLyptLROjXfSpIU_1TsQlCJ7q4WlXEixY9aqhie8CVYCrTb1E');.lst-kix_list_4-1>li{counter-increment:lst-ctn-kix_list_4-1}ol.lst-kix_list_7-0{list-style-type:none}.lst-kix_list_2-1>li{counter-increment:lst-ctn-kix_list_2-1}ol.lst-kix_list_9-0.start{counter-reset:lst-ctn-kix_list_9-0 0}.lst-kix_list_6-1>li{counter-increment:lst-ctn-kix_list_6-1}.lst-kix_list_8-1>li{counter-increment:lst-ctn-kix_list_8-1}ol.lst-kix_list_8-2.start{counter-reset:lst-ctn-kix_list_8-2 0}ol.lst-kix_list_3-1.start{counter-reset:lst-ctn-kix_list_3-1 0}ol.lst-kix_list_6-6.start{counter-reset:lst-ctn-kix_list_6-6 0}ol.lst-kix_list_7-4.start{counter-reset:lst-ctn-kix_list_7-4 0}.lst-kix_list_5-0>li{counter-increment:lst-ctn-kix_list_5-0}.lst-kix_list_7-0>li{counter-increment:lst-ctn-kix_list_7-0}.lst-kix_list_9-0>li{counter-increment:lst-ctn-kix_list_9-0}ol.lst-kix_list_2-3.start{counter-reset:lst-ctn-kix_list_2-3 0}ol.lst-kix_list_7-5{list-style-type:none}ol.lst-kix_list_7-6{list-style-type:none}ol.lst-kix_list_7-7{list-style-type:none}ol.lst-kix_list_7-8{list-style-type:none}ol.lst-kix_list_7-1{list-style-type:none}ol.lst-kix_list_1-5.start{counter-reset:lst-ctn-kix_list_1-5 0}ol.lst-kix_list_7-2{list-style-type:none}ol.lst-kix_list_7-3{list-style-type:none}ol.lst-kix_list_7-4{list-style-type:none}ol.lst-kix_list_9-6.start{counter-reset:lst-ctn-kix_list_9-6 0}ol.lst-kix_list_5-3.start{counter-reset:lst-ctn-kix_list_5-3 0}.lst-kix_list_2-3>li{counter-increment:lst-ctn-kix_list_2-3}.lst-kix_list_4-3>li{counter-increment:lst-ctn-kix_list_4-3}ol.lst-kix_list_4-5.start{counter-reset:lst-ctn-kix_list_4-5 0}.lst-kix_list_1-2>li{counter-increment:lst-ctn-kix_list_1-2}ol.lst-kix_list_3-7.start{counter-reset:lst-ctn-kix_list_3-7 0}.lst-kix_list_5-2>li{counter-increment:lst-ctn-kix_list_5-2}ol.lst-kix_list_8-8.start{counter-reset:lst-ctn-kix_list_8-8 0}.lst-kix_list_3-2>li{counter-increment:lst-ctn-kix_list_3-2}.lst-kix_list_7-2>li{counter-increment:lst-ctn-kix_list_7-2}.lst-kix_list_9-2>li{counter-increment:lst-ctn-kix_list_9-2}ol.lst-kix_list_8-7.start{counter-reset:lst-ctn-kix_list_8-7 0}.lst-kix_list_5-0>li:before{content:"(" counter(lst-ctn-kix_list_5-0,decimal) ") "}ol.lst-kix_list_6-0{list-style-type:none}ol.lst-kix_list_6-1{list-style-type:none}.lst-kix_list_5-4>li{counter-increment:lst-ctn-kix_list_5-4}.lst-kix_list_1-4>li{counter-increment:lst-ctn-kix_list_1-4}ol.lst-kix_list_1-6.start{counter-reset:lst-ctn-kix_list_1-6 0}.lst-kix_list_5-3>li:before{content:"" counter(lst-ctn-kix_list_5-3,decimal) ". "}ol.lst-kix_list_9-5.start{counter-reset:lst-ctn-kix_list_9-5 0}.lst-kix_list_5-2>li:before{content:"" counter(lst-ctn-kix_list_5-2,lower-roman) ". "}.lst-kix_list_8-3>li{counter-increment:lst-ctn-kix_list_8-3}.lst-kix_list_5-1>li:before{content:"" counter(lst-ctn-kix_list_5-1,upper-latin) ". "}.lst-kix_list_5-7>li:before{content:"" counter(lst-ctn-kix_list_5-7,upper-latin) ". "}.lst-kix_list_5-6>li:before{content:"" counter(lst-ctn-kix_list_5-6,decimal) ". "}.lst-kix_list_5-8>li:before{content:"" counter(lst-ctn-kix_list_5-8,lower-roman) ". "}.lst-kix_list_9-4>li{counter-increment:lst-ctn-kix_list_9-4}ol.lst-kix_list_6-6{list-style-type:none}ol.lst-kix_list_6-7{list-style-type:none}.lst-kix_list_5-4>li:before{content:"" counter(lst-ctn-kix_list_5-4,upper-latin) ". "}ol.lst-kix_list_6-8{list-style-type:none}.lst-kix_list_5-5>li:before{content:"" counter(lst-ctn-kix_list_5-5,lower-roman) ". "}ol.lst-kix_list_6-2{list-style-type:none}ol.lst-kix_list_6-3{list-style-type:none}ol.lst-kix_list_6-4{list-style-type:none}ol.lst-kix_list_6-5{list-style-type:none}ol.lst-kix_list_1-0.start{counter-reset:lst-ctn-kix_list_1-0 0}.lst-kix_list_6-1>li:before{content:"" counter(lst-ctn-kix_list_6-1,upper-latin) ". "}.lst-kix_list_6-3>li:before{content:"" counter(lst-ctn-kix_list_6-3,decimal) ". "}.lst-kix_list_6-5>li{counter-increment:lst-ctn-kix_list_6-5}.lst-kix_list_6-8>li{counter-increment:lst-ctn-kix_list_6-8}.lst-kix_list_6-0>li:before{content:"(" counter(lst-ctn-kix_list_6-0,decimal) ") "}.lst-kix_list_6-4>li:before{content:"" counter(lst-ctn-kix_list_6-4,upper-latin) ". "}.lst-kix_list_3-0>li{counter-increment:lst-ctn-kix_list_3-0}ol.lst-kix_list_4-0.start{counter-reset:lst-ctn-kix_list_4-0 0}.lst-kix_list_3-6>li{counter-increment:lst-ctn-kix_list_3-6}.lst-kix_list_6-2>li:before{content:"" counter(lst-ctn-kix_list_6-2,lower-roman) ". "}.lst-kix_list_2-5>li{counter-increment:lst-ctn-kix_list_2-5}.lst-kix_list_2-8>li{counter-increment:lst-ctn-kix_list_2-8}ol.lst-kix_list_3-2.start{counter-reset:lst-ctn-kix_list_3-2 0}.lst-kix_list_6-8>li:before{content:"" counter(lst-ctn-kix_list_6-8,lower-roman) ". "}.lst-kix_list_6-5>li:before{content:"" counter(lst-ctn-kix_list_6-5,lower-roman) ". "}.lst-kix_list_6-7>li:before{content:"" counter(lst-ctn-kix_list_6-7,upper-latin) ". "}ol.lst-kix_list_2-4.start{counter-reset:lst-ctn-kix_list_2-4 0}.lst-kix_list_6-6>li:before{content:"" counter(lst-ctn-kix_list_6-6,decimal) ". "}ol.lst-kix_list_1-3{list-style-type:none}ol.lst-kix_list_1-4{list-style-type:none}.lst-kix_list_2-7>li:before{content:"" counter(lst-ctn-kix_list_2-7,upper-latin) ". "}.lst-kix_list_2-7>li{counter-increment:lst-ctn-kix_list_2-7}ol.lst-kix_list_1-5{list-style-type:none}.lst-kix_list_7-4>li:before{content:"" counter(lst-ctn-kix_list_7-4,upper-latin) ". "}.lst-kix_list_7-6>li:before{content:"" counter(lst-ctn-kix_list_7-6,decimal) ". "}ol.lst-kix_list_1-6{list-style-type:none}ol.lst-kix_list_1-0{list-style-type:none}.lst-kix_list_2-5>li:before{content:"" counter(lst-ctn-kix_list_2-5,lower-roman) ". "}ol.lst-kix_list_6-2.start{counter-reset:lst-ctn-kix_list_6-2 0}ol.lst-kix_list_1-1{list-style-type:none}ol.lst-kix_list_1-2{list-style-type:none}.lst-kix_list_7-2>li:before{content:"" counter(lst-ctn-kix_list_7-2,lower-roman) ". "}.lst-kix_list_7-6>li{counter-increment:lst-ctn-kix_list_7-6}.lst-kix_list_8-6>li{counter-increment:lst-ctn-kix_list_8-6}ol.lst-kix_list_9-4.start{counter-reset:lst-ctn-kix_list_9-4 0}ol.lst-kix_list_4-6.start{counter-reset:lst-ctn-kix_list_4-6 0}ol.lst-kix_list_9-7{list-style-type:none}ol.lst-kix_list_9-8{list-style-type:none}ol.lst-kix_list_3-0.start{counter-reset:lst-ctn-kix_list_3-0 0}ol.lst-kix_list_9-3{list-style-type:none}ol.lst-kix_list_9-4{list-style-type:none}.lst-kix_list_5-7>li{counter-increment:lst-ctn-kix_list_5-7}.lst-kix_list_7-7>li{counter-increment:lst-ctn-kix_list_7-7}ol.lst-kix_list_9-5{list-style-type:none}.lst-kix_list_7-8>li:before{content:"" counter(lst-ctn-kix_list_7-8,lower-roman) ". "}ol.lst-kix_list_9-6{list-style-type:none}ol.lst-kix_list_4-3.start{counter-reset:lst-ctn-kix_list_4-3 0}ol.lst-kix_list_1-7{list-style-type:none}.lst-kix_list_4-7>li{counter-increment:lst-ctn-kix_list_4-7}ol.lst-kix_list_9-0{list-style-type:none}ol.lst-kix_list_1-8{list-style-type:none}ol.lst-kix_list_9-1{list-style-type:none}ol.lst-kix_list_9-2{list-style-type:none}.lst-kix_list_7-8>li{counter-increment:lst-ctn-kix_list_7-8}ol.lst-kix_list_2-5.start{counter-reset:lst-ctn-kix_list_2-5 0}.lst-kix_list_9-8>li{counter-increment:lst-ctn-kix_list_9-8}.lst-kix_list_2-6>li{counter-increment:lst-ctn-kix_list_2-6}.lst-kix_list_4-1>li:before{content:"" counter(lst-ctn-kix_list_4-1,upper-latin) ". "}ol.lst-kix_list_7-3.start{counter-reset:lst-ctn-kix_list_7-3 0}.lst-kix_list_9-2>li:before{content:"" counter(lst-ctn-kix_list_9-2,lower-roman) ". "}.lst-kix_list_4-3>li:before{content:"" counter(lst-ctn-kix_list_4-3,decimal) ". "}.lst-kix_list_4-5>li:before{content:"" counter(lst-ctn-kix_list_4-5,lower-roman) ". "}ol.lst-kix_list_5-7.start{counter-reset:lst-ctn-kix_list_5-7 0}.lst-kix_list_1-8>li{counter-increment:lst-ctn-kix_list_1-8}ol.lst-kix_list_1-4.start{counter-reset:lst-ctn-kix_list_1-4 0}.lst-kix_list_5-5>li{counter-increment:lst-ctn-kix_list_5-5}.lst-kix_list_3-5>li{counter-increment:lst-ctn-kix_list_3-5}ol.lst-kix_list_1-1.start{counter-reset:lst-ctn-kix_list_1-1 0}.lst-kix_list_9-0>li:before{content:"(" counter(lst-ctn-kix_list_9-0,decimal) ") "}.lst-kix_list_3-4>li{counter-increment:lst-ctn-kix_list_3-4}ol.lst-kix_list_4-4.start{counter-reset:lst-ctn-kix_list_4-4 0}.lst-kix_list_6-4>li{counter-increment:lst-ctn-kix_list_6-4}ol.lst-kix_list_9-2.start{counter-reset:lst-ctn-kix_list_9-2 0}.lst-kix_list_9-6>li:before{content:"" counter(lst-ctn-kix_list_9-6,decimal) ". "}.lst-kix_list_9-3>li{counter-increment:lst-ctn-kix_list_9-3}.lst-kix_list_9-4>li:before{content:"" counter(lst-ctn-kix_list_9-4,upper-latin) ". "}.lst-kix_list_6-3>li{counter-increment:lst-ctn-kix_list_6-3}ol.lst-kix_list_1-3.start{counter-reset:lst-ctn-kix_list_1-3 0}ol.lst-kix_list_2-8.start{counter-reset:lst-ctn-kix_list_2-8 0}ol.lst-kix_list_8-8{list-style-type:none}ol.lst-kix_list_1-2.start{counter-reset:lst-ctn-kix_list_1-2 0}ol.lst-kix_list_7-6.start{counter-reset:lst-ctn-kix_list_7-6 0}ol.lst-kix_list_6-1.start{counter-reset:lst-ctn-kix_list_6-1 0}ol.lst-kix_list_8-4{list-style-type:none}ol.lst-kix_list_8-5{list-style-type:none}ol.lst-kix_list_8-6{list-style-type:none}ol.lst-kix_list_8-7{list-style-type:none}ol.lst-kix_list_8-0{list-style-type:none}.lst-kix_list_9-8>li:before{content:"" counter(lst-ctn-kix_list_9-8,lower-roman) ". "}ol.lst-kix_list_8-1{list-style-type:none}.lst-kix_list_1-1>li:before{content:"" counter(lst-ctn-kix_list_1-1,upper-latin) ". "}ol.lst-kix_list_8-2{list-style-type:none}ol.lst-kix_list_8-3{list-style-type:none}.lst-kix_list_8-5>li{counter-increment:lst-ctn-kix_list_8-5}.lst-kix_list_1-3>li:before{content:"" counter(lst-ctn-kix_list_1-3,decimal) ". "}.lst-kix_list_4-8>li{counter-increment:lst-ctn-kix_list_4-8}.lst-kix_list_1-7>li:before{content:"" counter(lst-ctn-kix_list_1-7,upper-latin) ". "}ol.lst-kix_list_5-8.start{counter-reset:lst-ctn-kix_list_5-8 0}ol.lst-kix_list_2-7.start{counter-reset:lst-ctn-kix_list_2-7 0}.lst-kix_list_1-3>li{counter-increment:lst-ctn-kix_list_1-3}.lst-kix_list_1-5>li:before{content:"" counter(lst-ctn-kix_list_1-5,lower-roman) ". "}ol.lst-kix_list_9-1.start{counter-reset:lst-ctn-kix_list_9-1 0}.lst-kix_list_5-6>li{counter-increment:lst-ctn-kix_list_5-6}ol.lst-kix_list_7-5.start{counter-reset:lst-ctn-kix_list_7-5 0}.lst-kix_list_2-1>li:before{content:"" counter(lst-ctn-kix_list_2-1,upper-latin) ". "}ol.lst-kix_list_6-0.start{counter-reset:lst-ctn-kix_list_6-0 0}.lst-kix_list_2-3>li:before{content:"" counter(lst-ctn-kix_list_2-3,decimal) ". "}.lst-kix_list_4-2>li{counter-increment:lst-ctn-kix_list_4-2}ol.lst-kix_list_3-1{list-style-type:none}ol.lst-kix_list_3-2{list-style-type:none}.lst-kix_list_3-1>li{counter-increment:lst-ctn-kix_list_3-1}ol.lst-kix_list_3-3{list-style-type:none}ol.lst-kix_list_3-4.start{counter-reset:lst-ctn-kix_list_3-4 0}.lst-kix_list_5-1>li{counter-increment:lst-ctn-kix_list_5-1}ol.lst-kix_list_3-4{list-style-type:none}ol.lst-kix_list_3-0{list-style-type:none}.lst-kix_list_1-1>li{counter-increment:lst-ctn-kix_list_1-1}.lst-kix_list_7-1>li{counter-increment:lst-ctn-kix_list_7-1}.lst-kix_list_9-1>li{counter-increment:lst-ctn-kix_list_9-1}ol.lst-kix_list_2-6.start{counter-reset:lst-ctn-kix_list_2-6 0}.lst-kix_list_3-0>li:before{content:"(" counter(lst-ctn-kix_list_3-0,decimal) ") "}ol.lst-kix_list_7-7.start{counter-reset:lst-ctn-kix_list_7-7 0}.lst-kix_list_3-1>li:before{content:"" counter(lst-ctn-kix_list_3-1,upper-latin) ". "}.lst-kix_list_3-2>li:before{content:"" counter(lst-ctn-kix_list_3-2,lower-roman) ". "}.lst-kix_list_8-1>li:before{content:"" counter(lst-ctn-kix_list_8-1,upper-latin) ". "}ol.lst-kix_list_1-8.start{counter-reset:lst-ctn-kix_list_1-8 0}.lst-kix_list_4-0>li{counter-increment:lst-ctn-kix_list_4-0}.lst-kix_list_8-2>li:before{content:"" counter(lst-ctn-kix_list_8-2,lower-roman) ". "}.lst-kix_list_6-0>li{counter-increment:lst-ctn-kix_list_6-0}.lst-kix_list_8-0>li{counter-increment:lst-ctn-kix_list_8-0}.lst-kix_list_3-5>li:before{content:"" counter(lst-ctn-kix_list_3-5,lower-roman) ". "}.lst-kix_list_3-4>li:before{content:"" counter(lst-ctn-kix_list_3-4,upper-latin) ". "}.lst-kix_list_3-3>li:before{content:"" counter(lst-ctn-kix_list_3-3,decimal) ". "}ol.lst-kix_list_3-5{list-style-type:none}ol.lst-kix_list_3-6{list-style-type:none}.lst-kix_list_8-0>li:before{content:"(" counter(lst-ctn-kix_list_8-0,decimal) ") "}ol.lst-kix_list_3-7{list-style-type:none}ol.lst-kix_list_3-8{list-style-type:none}.lst-kix_list_8-7>li:before{content:"" counter(lst-ctn-kix_list_8-7,upper-latin) ". "}.lst-kix_list_3-8>li:before{content:"" counter(lst-ctn-kix_list_3-8,lower-roman) ". "}.lst-kix_list_8-5>li:before{content:"" counter(lst-ctn-kix_list_8-5,lower-roman) ". "}.lst-kix_list_8-6>li:before{content:"" counter(lst-ctn-kix_list_8-6,decimal) ". "}.lst-kix_list_2-0>li{counter-increment:lst-ctn-kix_list_2-0}.lst-kix_list_8-3>li:before{content:"" counter(lst-ctn-kix_list_8-3,decimal) ". "}.lst-kix_list_3-6>li:before{content:"" counter(lst-ctn-kix_list_3-6,decimal) ". "}.lst-kix_list_3-7>li:before{content:"" counter(lst-ctn-kix_list_3-7,upper-latin) ". "}.lst-kix_list_8-4>li:before{content:"" counter(lst-ctn-kix_list_8-4,upper-latin) ". "}ol.lst-kix_list_5-0.start{counter-reset:lst-ctn-kix_list_5-0 0}ol.lst-kix_list_8-5.start{counter-reset:lst-ctn-kix_list_8-5 0}ol.lst-kix_list_4-2.start{counter-reset:lst-ctn-kix_list_4-2 0}ol.lst-kix_list_9-3.start{counter-reset:lst-ctn-kix_list_9-3 0}.lst-kix_list_8-8>li:before{content:"" counter(lst-ctn-kix_list_8-8,lower-roman) ". "}ol.lst-kix_list_2-2{list-style-type:none}ol.lst-kix_list_2-3{list-style-type:none}ol.lst-kix_list_2-4{list-style-type:none}ol.lst-kix_list_7-2.start{counter-reset:lst-ctn-kix_list_7-2 0}ol.lst-kix_list_2-5{list-style-type:none}.lst-kix_list_4-4>li{counter-increment:lst-ctn-kix_list_4-4}ol.lst-kix_list_2-0{list-style-type:none}ol.lst-kix_list_2-1{list-style-type:none}.lst-kix_list_4-8>li:before{content:"" counter(lst-ctn-kix_list_4-8,lower-roman) ". "}ol.lst-kix_list_6-4.start{counter-reset:lst-ctn-kix_list_6-4 0}.lst-kix_list_4-7>li:before{content:"" counter(lst-ctn-kix_list_4-7,upper-latin) ". "}ol.lst-kix_list_5-6.start{counter-reset:lst-ctn-kix_list_5-6 0}ol.lst-kix_list_4-1.start{counter-reset:lst-ctn-kix_list_4-1 0}.lst-kix_list_7-3>li{counter-increment:lst-ctn-kix_list_7-3}ol.lst-kix_list_4-8.start{counter-reset:lst-ctn-kix_list_4-8 0}.lst-kix_list_8-4>li{counter-increment:lst-ctn-kix_list_8-4}ol.lst-kix_list_3-3.start{counter-reset:lst-ctn-kix_list_3-3 0}ol.lst-kix_list_2-6{list-style-type:none}ol.lst-kix_list_2-7{list-style-type:none}ol.lst-kix_list_2-8{list-style-type:none}ol.lst-kix_list_7-8.start{counter-reset:lst-ctn-kix_list_7-8 0}ol.lst-kix_list_7-1.start{counter-reset:lst-ctn-kix_list_7-1 0}ol.lst-kix_list_8-6.start{counter-reset:lst-ctn-kix_list_8-6 0}.lst-kix_list_3-3>li{counter-increment:lst-ctn-kix_list_3-3}ol.lst-kix_list_6-3.start{counter-reset:lst-ctn-kix_list_6-3 0}ol.lst-kix_list_5-5.start{counter-reset:lst-ctn-kix_list_5-5 0}ol.lst-kix_list_8-0.start{counter-reset:lst-ctn-kix_list_8-0 0}.lst-kix_list_7-0>li:before{content:"(" counter(lst-ctn-kix_list_7-0,decimal) ") "}.lst-kix_list_2-2>li{counter-increment:lst-ctn-kix_list_2-2}ol.lst-kix_list_4-7.start{counter-reset:lst-ctn-kix_list_4-7 0}.lst-kix_list_6-2>li{counter-increment:lst-ctn-kix_list_6-2}ol.lst-kix_list_5-0{list-style-type:none}.lst-kix_list_2-6>li:before{content:"" counter(lst-ctn-kix_list_2-6,decimal) ". "}.lst-kix_list_3-7>li{counter-increment:lst-ctn-kix_list_3-7}ol.lst-kix_list_5-1{list-style-type:none}ol.lst-kix_list_9-7.start{counter-reset:lst-ctn-kix_list_9-7 0}ol.lst-kix_list_5-2{list-style-type:none}.lst-kix_list_2-4>li:before{content:"" counter(lst-ctn-kix_list_2-4,upper-latin) ". "}.lst-kix_list_2-8>li:before{content:"" counter(lst-ctn-kix_list_2-8,lower-roman) ". "}.lst-kix_list_7-1>li:before{content:"" counter(lst-ctn-kix_list_7-1,upper-latin) ". "}.lst-kix_list_7-5>li:before{content:"" counter(lst-ctn-kix_list_7-5,lower-roman) ". "}.lst-kix_list_9-6>li{counter-increment:lst-ctn-kix_list_9-6}.lst-kix_list_6-6>li{counter-increment:lst-ctn-kix_list_6-6}ol.lst-kix_list_5-4.start{counter-reset:lst-ctn-kix_list_5-4 0}.lst-kix_list_7-3>li:before{content:"" counter(lst-ctn-kix_list_7-3,decimal) ". "}.lst-kix_list_9-7>li{counter-increment:lst-ctn-kix_list_9-7}ol.lst-kix_list_5-1.start{counter-reset:lst-ctn-kix_list_5-1 0}ol.lst-kix_list_5-7{list-style-type:none}.lst-kix_list_6-7>li{counter-increment:lst-ctn-kix_list_6-7}ol.lst-kix_list_5-8{list-style-type:none}ol.lst-kix_list_5-3{list-style-type:none}.lst-kix_list_8-7>li{counter-increment:lst-ctn-kix_list_8-7}ol.lst-kix_list_5-4{list-style-type:none}.lst-kix_list_1-7>li{counter-increment:lst-ctn-kix_list_1-7}ol.lst-kix_list_3-8.start{counter-reset:lst-ctn-kix_list_3-8 0}ol.lst-kix_list_5-5{list-style-type:none}ol.lst-kix_list_5-6{list-style-type:none}.lst-kix_list_7-7>li:before{content:"" counter(lst-ctn-kix_list_7-7,upper-latin) ". "}ol.lst-kix_list_8-1.start{counter-reset:lst-ctn-kix_list_8-1 0}.lst-kix_list_7-5>li{counter-increment:lst-ctn-kix_list_7-5}.lst-kix_list_9-5>li{counter-increment:lst-ctn-kix_list_9-5}.lst-kix_list_5-8>li{counter-increment:lst-ctn-kix_list_5-8}.lst-kix_list_4-0>li:before{content:"(" counter(lst-ctn-kix_list_4-0,decimal) ") "}.lst-kix_list_3-8>li{counter-increment:lst-ctn-kix_list_3-8}ol.lst-kix_list_6-8.start{counter-reset:lst-ctn-kix_list_6-8 0}.lst-kix_list_4-6>li{counter-increment:lst-ctn-kix_list_4-6}ol.lst-kix_list_1-7.start{counter-reset:lst-ctn-kix_list_1-7 0}.lst-kix_list_4-4>li:before{content:"" counter(lst-ctn-kix_list_4-4,upper-latin) ". "}ol.lst-kix_list_2-2.start{counter-reset:lst-ctn-kix_list_2-2 0}.lst-kix_list_1-5>li{counter-increment:lst-ctn-kix_list_1-5}ol.lst-kix_list_6-5.start{counter-reset:lst-ctn-kix_list_6-5 0}.lst-kix_list_4-2>li:before{content:"" counter(lst-ctn-kix_list_4-2,lower-roman) ". "}.lst-kix_list_4-6>li:before{content:"" counter(lst-ctn-kix_list_4-6,decimal) ". "}.lst-kix_list_9-3>li:before{content:"" counter(lst-ctn-kix_list_9-3,decimal) ". "}ol.lst-kix_list_7-0.start{counter-reset:lst-ctn-kix_list_7-0 0}.lst-kix_list_9-1>li:before{content:"" counter(lst-ctn-kix_list_9-1,upper-latin) ". "}ol.lst-kix_list_4-0{list-style-type:none}ol.lst-kix_list_4-1{list-style-type:none}ol.lst-kix_list_4-2{list-style-type:none}ol.lst-kix_list_4-3{list-style-type:none}.lst-kix_list_9-7>li:before{content:"" counter(lst-ctn-kix_list_9-7,upper-latin) ". "}.lst-kix_list_2-4>li{counter-increment:lst-ctn-kix_list_2-4}ol.lst-kix_list_6-7.start{counter-reset:lst-ctn-kix_list_6-7 0}ol.lst-kix_list_3-6.start{counter-reset:lst-ctn-kix_list_3-6 0}.lst-kix_list_9-5>li:before{content:"" counter(lst-ctn-kix_list_9-5,lower-roman) ". "}.lst-kix_list_5-3>li{counter-increment:lst-ctn-kix_list_5-3}ol.lst-kix_list_4-8{list-style-type:none}.lst-kix_list_7-4>li{counter-increment:lst-ctn-kix_list_7-4}.lst-kix_list_1-0>li:before{content:"(" counter(lst-ctn-kix_list_1-0,decimal) ") "}ol.lst-kix_list_4-4{list-style-type:none}ol.lst-kix_list_4-5{list-style-type:none}.lst-kix_list_1-2>li:before{content:"" counter(lst-ctn-kix_list_1-2,lower-roman) ". "}ol.lst-kix_list_2-0.start{counter-reset:lst-ctn-kix_list_2-0 0}ol.lst-kix_list_4-6{list-style-type:none}ol.lst-kix_list_4-7{list-style-type:none}ol.lst-kix_list_8-4.start{counter-reset:lst-ctn-kix_list_8-4 0}.lst-kix_list_1-4>li:before{content:"" counter(lst-ctn-kix_list_1-4,upper-latin) ". "}ol.lst-kix_list_3-5.start{counter-reset:lst-ctn-kix_list_3-5 0}.lst-kix_list_1-0>li{counter-increment:lst-ctn-kix_list_1-0}.lst-kix_list_8-8>li{counter-increment:lst-ctn-kix_list_8-8}.lst-kix_list_1-6>li{counter-increment:lst-ctn-kix_list_1-6}.lst-kix_list_1-6>li:before{content:"" counter(lst-ctn-kix_list_1-6,decimal) ". "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_list_2-0>li:before{content:"(" counter(lst-ctn-kix_list_2-0,decimal) ") "}ol.lst-kix_list_2-1.start{counter-reset:lst-ctn-kix_list_2-1 0}ol.lst-kix_list_8-3.start{counter-reset:lst-ctn-kix_list_8-3 0}.lst-kix_list_4-5>li{counter-increment:lst-ctn-kix_list_4-5}ol.lst-kix_list_9-8.start{counter-reset:lst-ctn-kix_list_9-8 0}.lst-kix_list_1-8>li:before{content:"" counter(lst-ctn-kix_list_1-8,lower-roman) ". "}.lst-kix_list_2-2>li:before{content:"" counter(lst-ctn-kix_list_2-2,lower-roman) ". "}ol.lst-kix_list_5-2.start{counter-reset:lst-ctn-kix_list_5-2 0}.lst-kix_list_8-2>li{counter-increment:lst-ctn-kix_list_8-2}ol{margin:0;padding:0}table td,table th{padding:0}.c19{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:412.8pt;border-top-color:#000000;border-bottom-style:solid}.c28{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:450.8pt;border-top-color:#000000;border-bottom-style:solid}.c0{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:90.2pt;border-top-color:#000000;border-bottom-style:solid}.c14{-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Calibri";font-style:italic}.c20{-webkit-text-decoration-skip:none;color:#0563c1;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Consolas";font-style:normal}.c24{-webkit-text-decoration-skip:none;color:#ff0000;font-weight:700;text-decoration:underline;text-decoration-skip-ink:none;font-size:11pt}.c51{-webkit-text-decoration-skip:none;color:#0070c0;font-weight:700;text-decoration:underline;text-decoration-skip-ink:none;font-size:11pt}.c5{padding-top:0pt;padding-bottom:0pt;line-height:2.0;text-align:justify;height:10pt}.c16{padding-top:0pt;padding-bottom:0pt;line-height:2.0;text-align:center}.c29{margin-left:32.6pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c43{font-size:11pt;font-family:"Consolas";color:#008000;font-weight:400}.c44{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:justify}.c13{margin-left:39.6pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c7{font-size:11pt;font-family:"Consolas";color:#008080;font-weight:400}.c27{font-size:11pt;font-family:"Consolas";color:#000000;font-weight:400}.c11{padding-top:0pt;padding-bottom:0pt;line-height:2.0;text-align:justify}.c31{font-size:11pt;font-family:"Consolas";color:#098658;font-weight:400}.c10{font-size:11pt;font-family:"Consolas";color:#0000ff;font-weight:400}.c12{font-size:11pt;font-family:"Consolas";color:#001188;font-weight:400}.c53{padding-top:0pt;padding-bottom:0pt;line-height:1.1500000000000001;text-align:justify}.c22{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c35{font-size:11pt;font-family:"Consolas";color:#cd3131;font-weight:400}.c58{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c4{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c34{margin-left:-5.4pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c36{padding-top:0pt;padding-bottom:0pt;line-height:2.0;text-align:right}.c47{-webkit-text-decoration-skip:none;color:#0563c1;text-decoration:underline;text-decoration-skip-ink:none}.c37{font-weight:400;font-size:10pt;font-family:"Wingdings"}.c8{font-weight:400;font-size:10pt;font-family:"Calibri"}.c26{font-weight:700;font-size:11pt;font-family:"Calibri"}.c45{font-weight:700;font-size:16pt;font-family:"Arial"}.c57{background-color:#ffffff;max-width:451.3pt;padding:72pt 72pt 72pt 72pt}.c50{font-weight:700;font-size:24pt;font-family:"Arial"}.c52{font-size:11pt;font-family:"Consolas";font-weight:400}.c42{font-weight:400;font-size:12pt;font-family:"Consolas"}.c23{font-weight:400;font-size:11pt;font-family:"Calibri"}.c1{font-size:11pt;font-family:"Times New Roman";font-weight:400}.c61{font-size:11pt;font-family:"Wingdings";font-weight:400}.c49{color:#000000;text-decoration:none;vertical-align:baseline}.c40{font-size:11pt;font-family:"Arial";font-weight:700}.c62{font-weight:400;font-size:11pt;font-family:"Arial"}.c32{margin-left:38pt;padding-left:0pt}.c25{color:inherit;text-decoration:inherit}.c60{width:33%;height:1px}.c46{font-weight:400;font-family:"Times New Roman"}.c48{orphans:2;widows:2}.c15{padding:0;margin:0}.c39{margin-left:11pt;text-indent:-11pt}.c59{margin-left:5pt;text-indent:-5pt}.c56{color:#ff0000;font-size:11pt}.c33{background-color:#fffffe}.c30{margin-left:10pt}.c38{text-indent:11pt}.c55{margin-left:38pt}.c21{vertical-align:super}.c18{height:0pt}.c6{text-indent:14.2pt}.c41{margin-left:14.2pt}.c9{background-color:#deebf6}.c54{color:#008080}.c17{font-style:italic}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Calibri";line-height:1.0;page-break-after:avoid;text-align:justify}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0;page-break-after:avoid;font-style:italic;text-align:justify}li{color:#000000;font-size:10pt;font-family:"Calibri"}p{margin:0;color:#000000;font-size:10pt;font-family:"Calibri"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Calibri";line-height:1.0;page-break-after:avoid;text-align:justify}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Calibri";line-height:1.0;page-break-after:avoid;text-align:justify}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Calibri";line-height:1.0;page-break-after:avoid;text-align:justify}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0;page-break-after:avoid;text-align:justify}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0;page-break-after:avoid;text-align:justify}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Calibri";line-height:1.0;page-break-after:avoid;text-align:justify}</style></head><body class="c57"><p class="c11"><span class="c4 c50">The select story</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c36"><span class="c47 c1"><a class="c25" href="https://www.google.com/url?q=https://aqjune.github.io/&amp;sa=D&amp;source=editors&amp;ust=1633325299631000&amp;usg=AOvVaw1H6GjX5-L3V7hWVGhg4tnL">Juneyoung Lee</a></span></p><p class="c36"><span class="c4 c1">Oct 4th 2021</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c1">This is a story about the removal of a compiler optimization that had been in LLVM for a long time.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c45">1. Background: How Does LLVM Compile &lsquo;e1 &amp;&amp; e2&rsquo;?</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">In C and C++, &lsquo;e1 &amp;&amp; e2&rsquo; </span><span class="c1 c17">conditionally</span><span class="c1">&nbsp;evaluates e2 only if e1 evaluates to true. This is called a short-circuit evaluation, and programmers often rely on this to write an idiom like &lsquo;idx &lt; LEN &amp;&amp; check(array[idx])&rsquo; that prevents the latter expression from raising an out of bounds access using the former condition</span><sup class="c1 c21"><a href="#ftnt1" id="ftnt_ref1">[1]</a></sup><span class="c4 c1">.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">To correctly implement short-circuit evaluation, Clang inserts a branch that has the result of e1 as its condition when it translates &lsquo;e1 &amp;&amp; e2&rsquo; into the intermediate representation of LLVM. Then, it places e2 at a basic block which is executed only if the branch is taken. For example, the emitted intermediate representation of LLVM &ndash; or simply LLVM IR &ndash; translated from &lsquo;idx &lt; LEN &amp;&amp; check(array[idx])&rsquo; roughly looks like this.</span></p><p class="c5"><span class="c4 c1"></span></p><a id="t.6165d8e760496b181d7b9e986a402f6e2c02ef94"></a><a id="t.0"></a><table class="c34"><tbody><tr class="c18"><td class="c28" colspan="1" rowspan="1"><p class="c11 c48 c33"><span class="c7">entry:</span></p><p class="c11 c33"><span class="c27">&nbsp; </span><span class="c35">%</span><span class="c10">e1</span><span class="c27">&nbsp;</span><span class="c35">=</span><span class="c27">&nbsp;</span><span class="c7">icmp</span><span class="c27">&nbsp;</span><span class="c7">slt</span><span class="c27">&nbsp;</span><span class="c7">i64</span><span class="c27">&nbsp;</span><span class="c7">%idx</span><span class="c27">, </span><span class="c7">%LEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c43">; e1 = %idx &lt; %LEN</span></p><p class="c11 c33"><span class="c27">&nbsp; </span><span class="c10">br</span><span class="c27">&nbsp;</span><span class="c7">i1</span><span class="c27">&nbsp;</span><span class="c7">%e1</span><span class="c27">, </span><span class="c7">label</span><span class="c27">&nbsp;</span><span class="c7">%land.rhs</span><span class="c27">, </span><span class="c7">label</span><span class="c27">&nbsp;</span><span class="c7">%land.end &nbsp; </span><span class="c43">; Is &lsquo;e1&rsquo; true?</span></p><p class="c5 c33"><span class="c2"></span></p><p class="c11 c33"><span class="c7">land.rhs:</span></p><p class="c11 c33 c38"><span class="c35">%</span><span class="c10">val</span><span class="c27">&nbsp;</span><span class="c35">=</span><span class="c27">&nbsp;</span><span class="c10">load</span><span class="c27">&nbsp;</span><span class="c7">i32</span><span class="c27">, </span><span class="c7">i32</span><span class="c27">* </span><span class="c7">...(array + idx)</span></p><p class="c11 c33"><span class="c27">&nbsp; </span><span class="c35">%</span><span class="c10">e2</span><span class="c27">&nbsp;</span><span class="c35">=</span><span class="c27">&nbsp;</span><span class="c7">call</span><span class="c27">&nbsp;</span><span class="c7">@check</span><span class="c27">(</span><span class="c7">i32</span><span class="c27">&nbsp;</span><span class="c35">%</span><span class="c31">val) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c27">&nbsp;</span><span class="c43">; e2 = check(array[idx])</span></p><p class="c11 c33 c38"><span class="c10">br</span><span class="c27">&nbsp;</span><span class="c7">label</span><span class="c27">&nbsp;</span><span class="c7">%land.end</span></p><p class="c5"><span class="c4 c23"></span></p><p class="c11 c48 c33"><span class="c42 c54">land.end:</span></p><p class="c11 c33"><span class="c4 c42">&nbsp; ... (%e2 if taken, otherwise %e1)</span></p></td></tr></tbody></table><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">However, we know that conditional branches are, well, expensive. It is the SimplifyCFG pass that tries to remove the branch that looks like the one in the above example. It checks whether hoisting out the evaluation of e2 from the condition branch is (A) correct and (B) beneficial. A is met if e2 does not have any side effect, or the operations in e2 are possible to execute </span><span class="c1 c17">speculatively</span><span class="c4 c1">. B is met if e2 is very cheap, e.g., a simple integer comparison.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">For the above example, neither A nor B holds because speculating a load is not safe or beneficial in general. For a simpler expression like &lsquo;idx &lt; LEN &amp;&amp; idx != 1&rsquo; however, both A and B hold. Therefore, SimplifyCFG optimizes it to an IR program that does not have a branch. To represent the output, it uses the select instruction. Select is equivalent to the ternary operator &lsquo;?:&rsquo; in C, except that the instruction can only take a constant or variable as its value operands. In the code generation, select can be efficiently lowered into an assembly like cmov in x86-64.</span></p><p class="c5"><span class="c4 c1"></span></p><a id="t.153b9ffaf146534a042dca3785d25a1b8ce34a2f"></a><a id="t.1"></a><table class="c34"><tbody><tr class="c18"><td class="c28" colspan="1" rowspan="1"><p class="c11 c48 c33 c38"><span class="c12">%e1</span><span class="c27">&nbsp;= icmp slt </span><span class="c7">i64</span><span class="c27">&nbsp;</span><span class="c12">%idx</span><span class="c27">, </span><span class="c12">%LEN</span><span class="c27">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c43">; %idx &lt; %LEN</span></p><p class="c11 c48 c33"><span class="c27">&nbsp; </span><span class="c12">%e2</span><span class="c27">&nbsp;= icmp ne &nbsp;</span><span class="c7">i64</span><span class="c27">&nbsp;</span><span class="c12">%idx</span><span class="c27">, </span><span class="c31">1</span><span class="c27">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c43">; %idx != 1</span></p><p class="c11 c33 c48"><span class="c27">&nbsp; </span><span class="c12">%res</span><span class="c27">&nbsp;= select </span><span class="c7">i1</span><span class="c27">&nbsp;</span><span class="c12">%e1</span><span class="c27">, </span><span class="c7">i1</span><span class="c27">&nbsp;</span><span class="c12">%e2</span><span class="c27">, </span><span class="c7">i1</span><span class="c27">&nbsp;</span><span class="c10">false</span><span class="c43">&nbsp;; %e1 ? %e2 : false</span></p></td></tr></tbody></table><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">The journey does not stop here, and LLVM goes one step further. The InstCombine pass in LLVM rewrites &lsquo;select&rsquo; to &lsquo;and&rsquo;. This is beneficial because it allows many optimizations for the bitwise &lsquo;and&rsquo; operation (e.g., &lsquo;x &amp; (y &amp; x)&rsquo; =&gt; &lsquo;x &amp; y&rsquo;) to be reused.</span></p><p class="c5"><span class="c4 c1"></span></p><a id="t.8b94ccf4131b7f78bb76ed9c26aaa34b4abe2755"></a><a id="t.2"></a><table class="c34"><tbody><tr class="c18"><td class="c28" colspan="1" rowspan="1"><p class="c11 c48 c33 c38"><span class="c12">%e1</span><span class="c27">&nbsp;= icmp slt </span><span class="c7">i64</span><span class="c27">&nbsp;</span><span class="c12">%idx</span><span class="c27">, </span><span class="c12">%LEN</span><span class="c27">&nbsp;</span><span class="c43">; %idx &lt; %LEN</span></p><p class="c11 c33"><span class="c27">&nbsp; </span><span class="c12">%e2</span><span class="c27">&nbsp;= icmp ne &nbsp;</span><span class="c7">i64</span><span class="c27">&nbsp;</span><span class="c12">%idx</span><span class="c27">, </span><span class="c31">1</span><span class="c27">&nbsp; &nbsp; &nbsp;</span><span class="c43">; %idx != 1</span></p><p class="c11 c33"><span class="c27">&nbsp; </span><span class="c12">%res</span><span class="c27">&nbsp;= and </span><span class="c7">i1</span><span class="c27">&nbsp;</span><span class="c12">%e1</span><span class="c27">, </span><span class="c12">%e2</span><span class="c27">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c43">; %e1 &amp; %e2</span></p></td></tr></tbody></table><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c45">2. The Canonicalization </span><span class="c45 c17">Was</span><span class="c4 c45">&nbsp;Correct, But It Isn&rsquo;t Anymore!</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">The topic of this post is about the validity of the last canonicalization (select -&gt; and). Unsurprisingly, the canonicalization has been in InstCombine for a long time; It was introduced in Apr 2004</span><sup class="c1 c21"><a href="#ftnt2" id="ftnt_ref2">[2]</a></sup><span class="c1">, which was a month after &lsquo;select&rsquo; was added to the list of IR instructions</span><sup class="c1 c21"><a href="#ftnt3" id="ftnt_ref3">[3]</a></sup><span class="c4 c1">.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">However, the canonicalization is incorrect because the optimized program is more undefined if one of its operands is a </span><span class="c1 c17">poison value</span><span class="c1">. Precisely speaking, the canonicalization </span><span class="c1 c17">had been</span><span class="c4 c1">&nbsp;correct in the past because the poison value was introduced six years after the canonicalization was written. After the introduction of the poison value, its correctness was in the gray area. Then, it explicitly became incorrect after a recent clarification of the semantics of the select instruction with respect to the poison value.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">Then, what is a poison value? A poison value is a conceptual value that represents the result of an erroneous operation. For operations like shifting with an amount larger than integer bitwidth - 1, the evaluation does not immediately make the program undefined, but a poison value is stored into the virtual register</span><sup class="c1 c21"><a href="#ftnt4" id="ftnt_ref4">[4]</a></sup><span class="c1">. If the program does not access the register at all, everything is fine. An instruction that takes a poison value as input also returns poison (with a few exceptions). If the instruction has a side-effect, the program behavior finally becomes entirely undefined. According to the GitHub commit history, it was initially called a &ldquo;trap value&rdquo;</span><sup class="c1 c21"><a href="#ftnt5" id="ftnt_ref5">[5]</a></sup><span class="c1">. After a year, it was renamed to a &ldquo;poison value&rdquo;</span><sup class="c1 c21"><a href="#ftnt6" id="ftnt_ref6">[6]</a></sup><span class="c4 c1">.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Then, why does the existence of a poison value make the canonicalization incorrect? It is because the &lsquo;select&rsquo; and &lsquo;and&rsquo; operations have different rules about how a poison input is propagated to the output. According to the latest LangRef, they are like this:</span></p><ol class="c15 lst-kix_list_2-0 start" start="1"><li class="c11 c32 li-bullet-0"><span class="c4 c1">For &lsquo;select false, poison, y&rsquo;, the result is simply y (not poison) because the true operand is not chosen.</span><span class="c1">&nbsp;</span><span class="c4 c1">Similarly, for &lsquo;select true, y, poison&rsquo;. This is analogous to how C&rsquo;s ternary expression is evaluated.</span></li><li class="c11 c32 li-bullet-0"><span class="c4 c1">For &lsquo;and 0, poison&rsquo;, the result must be poison. This is analogous to how &lsquo;x &amp; y&rsquo; in C evaluates. For example, &lsquo;0 &amp; (1 &lt;&lt; 32)&rsquo; has undefined behavior.</span></li></ol><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">According to this definition, canonicalizing &lsquo;select A, B, 0&rsquo; into &lsquo;and A, B&rsquo; is incorrect because the result is more poisonous if A is false and B is poison! To see the problem in practice, let&rsquo;s consider a C expression &lsquo;i &lt; 32 &amp;&amp; (16 &gt;= 1 &lt;&lt; i)&rsquo; where &lsquo;i&rsquo; is a 32-bit integer. The expression is evaluated to false if i is 32. However, the canonicalization in LLVM converts it into an expression that uses the bitwise &lsquo;and&rsquo;, which is analogous to &lsquo;i &lt; 32 &amp; (16 &gt;= 1 &lt;&lt; i)&rsquo;. According to the poison propagation rule, the result is more undefined if i = 32.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Two tables below show the results of the two expressions &lsquo;select x, y, false&rsquo; and &lsquo;and x, y&rsquo; when various values are given to x and y:</span></p><p class="c5"><span class="c4 c1"></span></p><a id="t.507c8a516eff74c2648aa8d5b3220bd341d22078"></a><a id="t.3"></a><table class="c13"><tbody><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">x \ y</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">poison</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td></tr></tbody></table><p class="c16"><span class="c4 c1">Table 1. The outputs of &lsquo;select i1 x, y, false&rsquo;</span></p><p class="c5"><span class="c4 c23"></span></p><a id="t.a7b4d56fd576bfab4d98856756b43b9a64430459"></a><a id="t.4"></a><table class="c13"><tbody><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">x \ y</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">poison</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c17 c24">poison</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td></tr></tbody></table><p class="c16"><span class="c4 c1">Table 2. The outputs of &lsquo;and i1 x, y&rsquo;</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">Note that the poison propagation rules were fully specified in LangRef in 2020, which is quite recent. Before this change, LangRef stated that instructions other than phi nodes depend on their operands. This meant that &lsquo;select false, poison, _&rsquo; was poison, invalidating lowering C&rsquo;s &ldquo;:?&rdquo; / &ldquo;&amp;&amp;&rdquo; / &ldquo;||&rdquo; into the select instruction. Due to these problems, LangRef was updated to treat &lsquo;select&rsquo; like a phi node in 2020, reaching to the current wordings</span><sup class="c1 c21"><a href="#ftnt7" id="ftnt_ref7">[7]</a></sup><span class="c4 c1">. Instead, the canonicalization explicitly became an invalid transformation.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">The canonicalization had been in the InstCombine pass of LLVM for more than 14 years. Then, it was discovered by a formal verification tool in 2014 that the canonicalization was problematic</span><sup class="c1 c21"><a href="#ftnt8" id="ftnt_ref8">[8]</a></sup><span class="c1">. However, the canonicalization was not fixed because it did not cause any real-world miscompilation</span><sup class="c1 c21"><a href="#ftnt9" id="ftnt_ref9">[9]</a></sup><span class="c1">. The first real-world miscompilation bug was reported in early 2020. It caused a patch that implements a valid optimization</span><sup class="c1 c21"><a href="#ftnt10" id="ftnt_ref10">[10]</a></sup><span class="c1">&nbsp;to be reverted because it interacted badly with the canonicalization, causing an end-to-end miscompilation. Then, after a poison constant was added to LLVM in 2020</span><sup class="c1 c21"><a href="#ftnt11" id="ftnt_ref11">[11]</a></sup><span class="c4 c1">&nbsp;and used more and more, many miscompilation bugs began to appear. This necessitated the removal of the old and incorrect canonicalization.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c45">3. Two Possible Solutions</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">To fix the incorrect canonicalization, we came up with two solutions. The first one was to simply remove it. However, this could lead to performance regressions in optimized programs. In LLVM, simplification patterns for the bitwise &lsquo;and&rsquo; operation (e.g., &lsquo;x &amp;&amp; (y &amp;&amp; x)&rsquo; -&gt; &lsquo;x &amp; (y &amp; x)&rsquo; -&gt; &lsquo;y &amp; x&rsquo;) were responsible for optimizing conjunctions (similarly for bitwise &lsquo;or&rsquo; and disjunctions). Without this canonicalization, conjunctions could not be optimized.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">The second solution was to use the freeze instruction. Canonicalizing &lsquo;select i1 x, y, false&rsquo; to &lsquo;and x, (freeze y)&rsquo; is correct because the freeze instruction blocks the propagation of the poison value. The two expressions are not equivalent as the latter has a more defined result. This transformation is correct because a compiler can remove undefinedness from the source program.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><a id="t.e4d673ab46e6f5ff29bdb1b15614db9abb61e15d"></a><a id="t.5"></a><table class="c13"><tbody><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">x \ y</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">poison</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c17 c51">false or true<br>(nondet. chosen)</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">poison</span></p></td></tr></tbody></table><p class="c16"><span class="c4 c1">Table 3. The outputs of &lsquo;and i1 x, (freeze y)&rsquo;. If x is true and y is poison, the result is well-defined.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">This solution salvages a portion of, but not all, optimizations. For example, &lsquo;x &amp;&amp; (y &amp;&amp; x)&rsquo; is canonicalized to &lsquo;and x, (freeze (and (freeze y), x))&rsquo;, which can be optimized into &lsquo;and x, (freeze y)&rsquo; thanks to the existing optimizations on the (1) &lsquo;and&rsquo; operation and (2) &lsquo;freeze&rsquo; operation.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">However, the second solution had one serious drawback: the insertion of freeze permanently removes undefinedness from the source program (look at the table above). Since undefined behavior in the program gives more freedom to compiler to do optimizations, its removal induces suboptimal code generation. I will leave a realistic optimization example that can be blocked at the bottom of this blog post.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Of course, it is reasonable to add a transformation that inserts freeze if the transformation brings a performance improvement. However, the canonicalization does not make the program fast or small by itself; it is the later pipeline that recognizes the bitwise operations and makes things better. Well, in theory, we could update all bitwise optimizations to accept selects as well and still achieve the goal.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c45">4. Biting the Bullet</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">After discussions, we chose to pursue the first solution. That was a tough decision because, as mentioned before, it meant we needed to start investigating all optimizations (as well as analyses) in LLVM and fix them.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c40">1) Conditionally Reallowing the Canonicalization If Valid</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">A question that was naturally raised was whether we could revive the canonicalization in certain cases to minimize the impact. For example, if &lsquo;y&rsquo; in &lsquo;x &amp;&amp; y&rsquo; is known to never be a poison value, then the canonicalization is valid. The never-poison analysis already existed in LLVM</span><sup class="c1 c21"><a href="#ftnt12" id="ftnt_ref12">[12]</a></sup><span class="c4 c1">&nbsp;and we could simply use it. However, this is not the only case where the canonicalization is valid.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Then, what is the precise analysis that allows this canonicalization? The only problematic case was when x was false and y was poison. What about implementing a value analysis that takes two values (x, y) and returns true if &lsquo;x != false or y != poison&rsquo;? According to the definition of implication, this is equivalent to &lsquo;y = poison implies x != false?&rsquo;. But, the analysis was too specific to this problem. There was also a canonicalization that rewrites a disjunction &lsquo;x || y&rsquo; to &lsquo;x | y&rsquo; as well, and the analysis certainly needed to be reused to this case. By slightly sacrificing the precision, we generalized it to &lsquo;does y = poison imply (x != false /\ x != true)&rsquo;, which is equivalent to</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c16 c6"><span class="c4 c1">Does &lsquo;y = poison&rsquo; imply &lsquo;x = poison&rsquo;?</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">The new value analysis function was called &lsquo;impliesPoison(y, x)&rsquo;. It is currently located at Analysis/ValueTracking.{h,cpp}.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Let&rsquo;s visualize the cases where impliesPoison works. In table 4, a cell has a check (v) if it is theoretically correct to canonicalize &lsquo;select i1 x, y, false&rsquo; to &lsquo;and i1 x, y&rsquo; when (x, y) have the corresponding values. Also, a cell is colored blue if impliesPoison(y, x) is true in that case. Note that impliesPoison(y, x) is true if y is not poison. This is because false implies anything in logic.</span></p><p class="c5"><span class="c1 c4"></span></p><a id="t.09025d246e667baafbcd5233f56c33526c11d44d"></a><a id="t.6"></a><table class="c13"><tbody><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">x \ y</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">false</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">true</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">poison</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">false</span></p></td><td class="c0 c9" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">v</span></p></td><td class="c0 c9" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">v</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c56">x</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">true</span></p></td><td class="c0 c9" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">v</span></p></td><td class="c0 c9" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">v</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">v</span></p></td></tr><tr class="c18"><td class="c0" colspan="1" rowspan="1"><p class="c16"><span class="c4 c26">poison</span></p></td><td class="c0 c9" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">v</span></p></td><td class="c0 c9" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">v</span></p></td><td class="c0 c9" colspan="1" rowspan="1"><p class="c11"><span class="c4 c23">v</span></p></td></tr></tbody></table><p class="c16"><span class="c4 c1">Table 4. Using impliesPoison covers most cases.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">You can see that using impliesPoison reallows the canonicalization in most cases.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Then, how is the impliesPoison(y, x) implemented? We inductively defined impliesPoison as follows:</span></p><ol class="c15 lst-kix_list_4-0 start" start="1"><li class="c11 c32 li-bullet-0"><span class="c4 c1">The base case is y = x. impliesPoison(x, x) is trivially true.</span></li><li class="c11 c32 li-bullet-0"><span class="c4 c1">If x = op x1 x2 and op propagates poison, then</span><span class="c1"><br> &nbsp;</span><span class="c4 c1">impliesPoison(y, op x1 x2) = impliesPoison(y, x1) \/ impliesPoison(y, x2).</span></li><li class="c11 c32 li-bullet-0"><span class="c4 c1">If y = op y1 y2 and op never creates poison (e.g., add without any flag), then y = poison means either y1 = poison \/ y2 = poison. In both cases, x must be poison.<br> &nbsp;impliesPoison(op y1 y2, x) = impliesPoison(y1, x) /\ impliesPoison(y2, x).</span></li></ol><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Interestingly, this analysis turned out to work well in practice. It was because many optimizations on conjunctions were dealing with formulae whose two subexpressions use the same set of variable, e.g., &lsquo;idx &lt; 10 &amp;&amp; idx &lt; 20&rsquo; or &lsquo;(a | b) &amp;&amp; (~a | b)&rsquo;. Note that we can easily prove that impliesPoison(idx &lt; 20, idx &lt; 10) is true.</span></p><ol class="c15 lst-kix_list_6-0 start" start="1"><li class="c11 c32 li-bullet-0"><span class="c4 c1">idx &lt; 20 is poison iff idx is poison, therefore it is enough to check impliesPoison(idx, idx &lt; 10)</span></li><li class="c11 c32 li-bullet-0"><span class="c4 c1">Similarly, idx &lt; 10 is poison iff idx is poison, so it is equivalent to impliesPoison(idx, idx), which is true!</span></li></ol><p class="c11 c6"><span class="c4 c1">Therefore, the formula can be canonicalized into &lsquo;and (idx &lt; 10), (idx &lt; 20)&rsquo;. Similarly, impliesPoison(~a | b, a | b) is true.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c40">2) Updating Optimizations to Recognize Selects</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Resurrecting the canonicalization using impliesPoison could partially recover the performance. However, the performance recovery was still not very satisfactory. We needed to update existing optimizations on the &lsquo;and&rsquo; operator to deal with the select form (similarly for &lsquo;or&rsquo; and its select form as well).</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">In order to facilitate updating existing optimizations, two pattern matchers were added into LLVM: m_LogicalAnd and m_LogicalOr. m_LogicalAnd(e, A, B) checks whether expression e is either &lsquo;and i1 e1, e2&rsquo; or &lsquo;select i1 e1, e2, false&rsquo; (allowing a vector type of i1s as well) such that &lsquo;e1&rsquo; satisfies pattern A and &lsquo;e2&rsquo; satisfies pattern B; similarly, m_LogicalOr checks whether the expression is a disjunction. Also, to track missing optimizations on the select form, unit tests on &lsquo;and&rsquo; optimizations in LLVM were duplicated and edited in order to track whether &lsquo;select&rsquo; instructions are also optimized. To make the comparison of the assembly outputs easy, a command-line flag that disables the select canonicalization was added as well.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">These preparations made the updates easier than before, but we still needed to visit each optimization and carefully check whether generalizing it to accepting the &lsquo;select&rsquo; form. The impliesPoison-based canonicalization could significantly reduce the number of optimizations to visit, but there were still many. Fortunately, we find that many of the remaining optimizations were recognizing conjunctions at conditional branches, and they fell into one of these two cases:</span></p><p class="c5"><span class="c4 c1"></span></p><ol class="c15 lst-kix_list_8-0 start" start="1"><li class="c11 c32 li-bullet-0"><span class="c4 c1">There are optimizations that recognize a conjunction in a conditional branch and use it in the taken branch:</span></li></ol><a id="t.0f1787682aee1170b857db42a923083f7a7d7196"></a><a id="t.7"></a><table class="c29"><tbody><tr class="c18"><td class="c19" colspan="1" rowspan="1"><p class="c11"><span class="c2">if (cond1 &amp;&amp; a == b) {<br> &nbsp;use(a); // can be optimized to &lsquo;use(b)&rsquo; because neither</span></p><p class="c11"><span class="c52">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // </span><span class="c2">a nor b can be poison.<br>}</span></p></td></tr></tbody></table><p class="c11 c55"><span class="c4 c1">This optimization is still valid even if &lsquo;cond1 &amp;&amp; cond2&rsquo; is not canonicalized into the &lsquo;and&rsquo; form.</span></p><ol class="c15 lst-kix_list_8-0" start="2"><li class="c11 c32 li-bullet-0"><span class="c4 c1">On the other hand, there are optimizations that recognize a conjunction and use it in the </span><span class="c1 c17 c49">untaken</span><span class="c4 c1">&nbsp;branch:</span></li></ol><a id="t.f945e71cc8d7bcf5765acd293594e98c3ae09b8a"></a><a id="t.8"></a><table class="c29"><tbody><tr class="c18"><td class="c19" colspan="1" rowspan="1"><p class="c11"><span class="c2">int i = 0;<br>while (i &lt; n1 &amp;&amp; i &lt; n2) { i++; }<br>use(i); // cannot be optimized to &lsquo;use(min(n1, n2))&rsquo; because<br> &nbsp; &nbsp; &nbsp; &nbsp;// n1 = 0 /\ n2 = poison!</span></p></td></tr></tbody></table><p class="c11 c55"><span class="c4 c1">This optimization isn&rsquo;t valid because replacing use(i) with use(min(0, poison)) = use(poison) is incorrect.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c40">3) Adding More Optimizations to Recover Performance</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">To fully recover the performance, we added peephole optimizations that simplify expressions containing selects. The simplest and new one was an optimization folding &lsquo;a &amp;&amp; (a &amp;&amp; b)&rsquo; (in C) into &lsquo;a &amp;&amp; b&rsquo; (in C)</span><sup class="c1 c21"><a href="#ftnt13" id="ftnt_ref13">[13]</a></sup><span class="c1">. General patterns were added by calling isImpliedCondition(lhs, rhs) in LLVM&rsquo;s value analysis</span><sup class="c1 c21"><a href="#ftnt14" id="ftnt_ref14">[14]</a></sup><span class="c1">. isImpliedCondition is an LLVM function that returns true if lhs = true implies rhs = true (e.g., isImpliedCondition(&ldquo;x &lt; 10&rdquo;, &ldquo;x &lt; 20&rdquo;) returns true). For example, &lsquo;(a || b) &amp;&amp; c&rsquo; is now simplified into &lsquo;a &amp;&amp; c&rsquo; if isImpliedCondition(c, !b) holds. Optimizations for expressions containing both &lsquo;select&rsquo; and bin ops - such as folding &lsquo;a &amp; (b ? A : B)&rsquo; into &lsquo;a ? A : false&rsquo; if a = true implies b = true &ndash; were added as well</span><sup class="c1 c21"><a href="#ftnt15" id="ftnt_ref15">[15]</a></sup><span class="c4 c1">.</span></p><p class="c11 c6"><span class="c4 c1">Checking the correctness of these optimizations was not trivial due to the existence of poison and undef values. For each patch, we left link(s) to Alive2 to show the validity of transformation.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">Fixing some optimizations on the and/or operations required additional tricks. For example, LLVM simplifies &lsquo;((t1 &amp; k) == 0) | ((t4 &amp; k) == 0)&rsquo; into &lsquo;((t1 | t4) &amp; k) == 0&rsquo; because the latter has fewer operations. However, the select version of the input pattern - &lsquo;((t1 &amp; k) == 0) || ((t4 &amp; k) == 0)&rsquo; - cannot be optimized to the latter because the result may be more undefined if t4 is poison. To correctly fix it, t4 must be replaced with &lsquo;freeze t4&rsquo;. This tweak was necessary to resolve 6% performance regression after the removal of canonicalization</span><sup class="c1 c21"><a href="#ftnt16" id="ftnt_ref16">[16]</a></sup><span class="c4 c1">.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">We updated LLVM to recognize the select form of conjunction as having the cost of an &lsquo;and&rsquo; operation</span><sup class="c1 c21"><a href="#ftnt17" id="ftnt_ref17">[17]</a></sup><span class="c1">. The backend was updated to generate optimized assembly for the selects</span><sup class="c1 c21"><a href="#ftnt18" id="ftnt_ref18">[18]</a></sup><span class="c4 c1">.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c45">5. Removing the Canonicalization in Three Steps</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">The canonicalization was gradually removed from LLVM in three steps.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">First, we left InstCombine as the only place where the canonicalization happened. Previously, there were several optimizations that used the &lsquo;and&rsquo; operation to create a conjunction expression in an IR program (&lsquo;or&rsquo; for a disjunction as well). For example, SimplifyCFG was inserting &lsquo;and&rsquo; to represent the merged condition after merging two consecutive branches into one</span><sup class="c1 c21"><a href="#ftnt19" id="ftnt_ref19">[19]</a></sup><span class="c1">. Also, a loop vectorizer and peephole optimization were incorrectly introducing &lsquo;and&rsquo; as well</span><sup class="c1 c21"><a href="#ftnt20" id="ftnt_ref20">[20]</a></sup><span class="c4 c1">.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">Second, we conditionally disabled the InstCombine canonicalization</span><sup class="c1 c21"><a href="#ftnt21" id="ftnt_ref21">[21]</a></sup><span class="c1">&nbsp;to fix a miscompilation bug reported in March 2021</span><sup class="c1 c21"><a href="#ftnt22" id="ftnt_ref22">[22]</a></sup><span class="c4 c1">. The canonicalization was disabled if the second operand of the select (&lsquo;b&rsquo; in &lsquo;select a, b, false&rsquo;) was a poison-creating operation like &lsquo;add nsw&rsquo;. Since many arithmetic operations translated from C have poison-generating flags, it made the canonicalization seldomly happen. Fortunately, no performance regression that was hard to fix was reported after this patch had landed. This meant that the complete removal of the canonicalization was prospective.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">The last step was to fully remove the canonicalization</span><sup class="c1 c21"><a href="#ftnt23" id="ftnt_ref23">[23]</a></sup><span class="c1">. It was spurred by another miscompilation bug report due to this canonicalization</span><sup class="c1 c21"><a href="#ftnt24" id="ftnt_ref24">[24]</a></sup><span class="c4 c1">. After a lot of optimizations were added in advance to avoid a performance regression, the canonicalization was fully removed in May 2021.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">Interestingly, after each step, hidden bugs and issues in LLVM were revealed</span><sup class="c1 c21"><a href="#ftnt25" id="ftnt_ref25">[25]</a></sup><span class="c4 c1">. We found miscompilation bugs after the first step and the third step. Also, an unexpected performance regression and infinite loop were found after the second step. If the removal of the canonicalization had been done at once, downstream projects of LLVM must have fallen into a chaotic state. Gradually removing the canonicalization helped us avoid the hassle.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c4 c45">6. Conclusion &amp; What&rsquo;s Next?</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c41"><span class="c1">That was a </span><span class="c1 c17">long</span><span class="c4 c1">&nbsp;trip!</span></p><p class="c5 c41"><span class="c4 c1"></span></p><p class="c11 c41"><span class="c4 c1">To summarize, the story was as follows:</span></p><ol class="c15 lst-kix_list_9-0 start" start="1"><li class="c11 c32 li-bullet-0"><span class="c4 c1">LLVM had been canonicalizing selects into the and/or binary operations for a long time.</span></li><li class="c11 c32 li-bullet-0"><span class="c4 c1">The recent clarification of the semantics of select in LangRef explicitly made the canonicalization an incorrect one.</span></li><li class="c11 c32 li-bullet-0"><span class="c4 c1">There were two possible solutions, and we chose the solution that was unlikely to cause a performance regression if everything was correctly fixed.</span><span class="c1">&nbsp;</span><span class="c4 c1">Existing optimizations were updated and new ones were added to simplify expressions containing selects. Also, a new analysis &lsquo;impliesPoison(x,y)&rsquo; was added to reenable the canonicalization if possible.</span></li><li class="c11 c32 li-bullet-0"><span class="c4 c1">The canonicalization was gradually disabled in three steps to avoid undesirable consequences. It was fully removed in May 2021.</span></li></ol><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">The changes have been shipped to the official release of LLVM 13.0.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">However, the story isn&rsquo;t over yet. A report</span><sup class="c1 c21"><a href="#ftnt26" id="ftnt_ref26">[26]</a></sup><span class="c4 c1">&nbsp;demonstrates suboptimal code generations due to uncovered simplification patterns on select. This implies that there still exists a set of transformations that are uncovered by our updates. Furthermore, we don&rsquo;t know which transformations are uncovered unless users report performance regressions. Exhaustively adding all possible optimizations on select is infeasible and will cause the compiler to run infinitely.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">Then, how can we solve this problem? The problem exists because LLVM has poison value, but we cannot change the IR because its existence allows another set of important optimizations. Instead, we can update the frontends (e.g., C/C++, Swift, Rust) to leave </span><span class="c1 c17">never-poison</span><span class="c4 c1">&nbsp;marks at SSA variables. Then, the canonicalization will fire again because impliesPoison(y,x) returns true if y is never poison (it&rsquo;s because false implies everything).</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">This is somewhat analogous to how the alignment information of a pointer is encoded in LLVM IR. Many architectures support fast and wide memory instructions that are tailored for specific alignment(s). Therefore, to use the instructions, it is important to check whether a dereferencing pointer has the alignment. However, in LLVM IR, a pointer type &lsquo;ty*&rsquo; has nothing to do with its underlying type &lsquo;ty&rsquo;. This means that one cannot infer the alignment of a pointer from &lsquo;ty&rsquo;. Instead, it is the frontend that leaves the alignment information. For example, the C language standard states that types have alignment requirements, and the addresses of objects of that type must satisfy the restriction. The clang frontend attaches the &lsquo;align&rsquo; attribute (with the corresponding alignment number) to pointers and instructions using them.</span></p><p class="c5 c6"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">Actually, LLVM IR already has an attribute for presenting the </span><span class="c1 c17">never-poison</span><span class="c1">&nbsp;information - it is the &lsquo;noundef&rsquo; attribute. If the &lsquo;noundef&rsquo; attribute is attached to a function argument, its value is neither undef nor poison because passing such values to the argument is undefined behavior. What is cool is that clang already has a command-line flag that enables attaching the &lsquo;noundef&rsquo; attribute to arguments if C/C++ standards allow doing so</span><sup class="c1 c21"><a href="#ftnt27" id="ftnt_ref27">[27]</a></sup><span class="c1">. Turning on the flag effectively resolved a performance regression after another miscompilation bug was fixed using the freeze instruction. I believe that the flag will also help address unseen performance regressions after the removal of select canonicalization as well. To enable the flag by default, a student who participated in Google Summer of Code this year created a patch</span><sup class="c1 c21"><a href="#ftnt28" id="ftnt_ref28">[28]</a></sup><span class="c1">. We welcome any support for reviewing our patch! </span><span class="c61">&#9786;</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11"><span class="c40">Appendix I.</span><span class="c4 c62">&nbsp;An example showing that folding &lsquo;select x, y, false&rsquo; to &lsquo;add x, (freeze y)&rsquo; can block further optimizations.</span></p><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c1">The inserted freeze can block induction variable widening. &ldquo;The nsw story&rdquo;</span><sup class="c1 c21"><a href="#ftnt29" id="ftnt_ref29">[29]</a></sup><span class="c4 c1">&nbsp;has a nice background about the transformation. Imagine this loop:</span></p><a id="t.01a0ae718ac182a660357a35592e1125e9cc2ca7"></a><a id="t.9"></a><table class="c34"><tbody><tr class="c18"><td class="c28" colspan="1" rowspan="1"><p class="c11"><span class="c2">// n is a 64-bit integer</span></p><p class="c11"><span class="c2">int y = 0;</span></p><p class="c11"><span class="c2">while (x &amp;&amp; (y &lt;= n)) {</span></p><p class="c11 c30"><span class="c2">arr[y] = 0;<br>y = add nsw y, 1</span></p><p class="c11"><span class="c2">}</span></p></td></tr></tbody></table><p class="c5"><span class="c4 c23"></span></p><p class="c11 c6"><span class="c4 c1">If the branch condition is canonicalized into &lsquo;and&rsquo; with its second operand frozen, it becomes:</span></p><a id="t.c765c561e093c074caca9373f5f6f91285875910"></a><a id="t.10"></a><table class="c34"><tbody><tr class="c18"><td class="c28" colspan="1" rowspan="1"><p class="c11"><span class="c2">int y = 0;</span></p><p class="c11 c39"><span class="c2">while (and x, (freeze (y &lt;= n))) {</span></p><p class="c11 c38"><span class="c2">arr[y] = 0;</span></p><p class="c11 c30"><span class="c2">y = add nsw y, 1</span></p><p class="c11"><span class="c2">}</span></p></td></tr></tbody></table><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">Let&rsquo;s assume that x was true, leaving &ldquo;freeze (y &lt;= n)&rdquo; only:</span></p><a id="t.ba4357aa8df323e3d7d7b45722beaba148a39ff0"></a><a id="t.11"></a><table class="c34"><tbody><tr class="c18"><td class="c28" colspan="1" rowspan="1"><p class="c11"><span class="c2">int y = 0;</span></p><p class="c11 c39"><span class="c2">while (freeze (y &lt;= n)) {<br>arr[y] = 0;</span></p><p class="c11 c38"><span class="c2">y = add nsw y, 1</span></p><p class="c11"><span class="c52">}</span></p></td></tr></tbody></table><p class="c5"><span class="c4 c1"></span></p><p class="c11 c6"><span class="c4 c1">This is bad because the loop condition is frozen. This blocks loop optimizations such as induction variable widening on y. If there was no freeze at all, like this:</span></p><a id="t.4c396017d07457e506c56840a37ef8058c69634c"></a><a id="t.12"></a><table class="c34"><tbody><tr class="c18"><td class="c28" colspan="1" rowspan="1"><p class="c11"><span class="c2">int y = 0;</span></p><p class="c11 c39"><span class="c2">while (y &lt;= n) {<br>arr[y] = 0;</span></p><p class="c11 c38"><span class="c2">y = add nsw y, 1</span></p><p class="c11"><span class="c52">}</span></p></td></tr></tbody></table><p class="c5"><span class="c4 c1"></span></p><p class="c11 c41"><span class="c1">y could be widened into 64 bits integer, which is beneficial.</span></p><hr class="c60"><div><p class="c53"><a href="#ftnt_ref1" id="ftnt1">[1]</a><span class="c46">&nbsp;One can also use a similar technique for `e1 || e2`. I will mainly use &lsquo;e1 &amp;&amp; e2&rsquo; as an example for brevity in this post.</span></p></div><div><p class="c22"><a href="#ftnt_ref2" id="ftnt2">[2]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://github.com/llvm/llvm-project/commit/1c631e813da9d&amp;sa=D&amp;source=editors&amp;ust=1633325299741000&amp;usg=AOvVaw3DpmiQ5h8nD8s-67-vX9UD">https://github.com/llvm/llvm-project/commit/1c631e813da9d</a></span></p></div><div><p class="c22"><a href="#ftnt_ref3" id="ftnt3">[3]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://github.com/llvm/llvm-project/commit/439b128ce7b6d4a09fc2c042c5330aef0323d4a6&amp;sa=D&amp;source=editors&amp;ust=1633325299741000&amp;usg=AOvVaw1OwQ2PRqA_w0iiwowJ0mtm">https://github.com/llvm/llvm-project/commit/439b128ce7b6d4a09fc2c042c5330aef0323d4a6</a></span></p></div><div><p class="c22"><a href="#ftnt_ref4" id="ftnt4">[4]</a><span class="c3">&nbsp;I will not explain what undefined behavior is in this post because there are a lot of other great posts that describe it.</span></p></div><div><p class="c22"><a href="#ftnt_ref5" id="ftnt5">[5]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://github.com/llvm/llvm-project/commit/ffc9a6b4ac6b979bec1592cfc9f2722f9bb031ed&amp;sa=D&amp;source=editors&amp;ust=1633325299742000&amp;usg=AOvVaw01tOKDFuZVzUfW69m3NuSW">https://github.com/llvm/llvm-project/commit/ffc9a6b4ac6b979bec1592cfc9f2722f9bb031ed</a></span></p></div><div><p class="c22"><a href="#ftnt_ref6" id="ftnt6">[6]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://github.com/llvm/llvm-project/commit/9a2a0933edeb7970a6f11f7de68be68ddbce6b4f&amp;sa=D&amp;source=editors&amp;ust=1633325299743000&amp;usg=AOvVaw0OnxkGzGAifesSSTdJDFeK">https://github.com/llvm/llvm-project/commit/9a2a0933edeb7970a6f11f7de68be68ddbce6b4f</a></span></p></div><div><p class="c22"><a href="#ftnt_ref7" id="ftnt7">[7]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/rGfaba1d034a046305a3a7902e1753bf5dfc4f686e&amp;sa=D&amp;source=editors&amp;ust=1633325299744000&amp;usg=AOvVaw1Lgu-4prd0T1dlm-S6BlW1">https://reviews.llvm.org/rGfaba1d034a046305a3a7902e1753bf5dfc4f686e</a></span></p></div><div><p class="c22"><a href="#ftnt_ref8" id="ftnt8">[8]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://groups.google.com/g/llvm-dev/c/eQ7Fw2C_O9Q&amp;sa=D&amp;source=editors&amp;ust=1633325299744000&amp;usg=AOvVaw0_cBla9rohNvMUro1cVIDn">https://groups.google.com/g/llvm-dev/c/eQ7Fw2C_O9Q</a></span></p></div><div><p class="c22 c59"><a href="#ftnt_ref9" id="ftnt9">[9]</a><span class="c3">&nbsp;Fortunately, the situation is much better now. If you report that a transformation is buggy with anAlive2 proof (</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://alive2.llvm.org/&amp;sa=D&amp;source=editors&amp;ust=1633325299745000&amp;usg=AOvVaw3SyVybgvDSyP5tHubXF_ok">https://alive2.llvm.org/</a></span><span class="c3">), it is likely to be fixed. </span><span class="c4 c37">&#9786;</span></p></div><div><p class="c22"><a href="#ftnt_ref10" id="ftnt10">[10]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D72396&amp;sa=D&amp;source=editors&amp;ust=1633325299745000&amp;usg=AOvVaw1Me23VcBSJwJjkb6QKzlnO">https://reviews.llvm.org/D72396</a></span></p></div><div><p class="c22"><a href="#ftnt_ref11" id="ftnt11">[11]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D71126&amp;sa=D&amp;source=editors&amp;ust=1633325299746000&amp;usg=AOvVaw1lrpYeWNIqtdnSWcda8yAW">https://reviews.llvm.org/D71126</a></span></p></div><div><p class="c22"><a href="#ftnt_ref12" id="ftnt12">[12]</a><span class="c4 c8">&nbsp;</span><span class="c3">It is the isGuaranteedNotToBePoison function in ValueTracking.{h,cpp}.&#39;</span></p></div><div><p class="c22"><a href="#ftnt_ref13" id="ftnt13">[13]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D96945&amp;sa=D&amp;source=editors&amp;ust=1633325299747000&amp;usg=AOvVaw2s7oRyQ5cvy3jqXlAuiJcE">https://reviews.llvm.org/D96945</a></span></p></div><div><p class="c22"><a href="#ftnt_ref14" id="ftnt14">[14]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D101375&amp;sa=D&amp;source=editors&amp;ust=1633325299747000&amp;usg=AOvVaw0dwoTXGGOHl0AbxpCSstwf">https://reviews.llvm.org/D101375</a></span><span class="c3">, </span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D101807&amp;sa=D&amp;source=editors&amp;ust=1633325299748000&amp;usg=AOvVaw3-J3vmpUAa3XkAwDyJbEz0">https://reviews.llvm.org/D101807</a></span></p></div><div><p class="c22"><a href="#ftnt_ref15" id="ftnt15">[15]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D101720&amp;sa=D&amp;source=editors&amp;ust=1633325299748000&amp;usg=AOvVaw3pDxFiHQTseOXBIrTxML5Q">https://reviews.llvm.org/D101720</a></span></p></div><div><p class="c22"><a href="#ftnt_ref16" id="ftnt16">[16]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D101423&amp;sa=D&amp;source=editors&amp;ust=1633325299749000&amp;usg=AOvVaw2EeJ8lTDRlGLdPxed5MNJr">https://reviews.llvm.org/D101423</a></span></p></div><div><p class="c22"><a href="#ftnt_ref17" id="ftnt17">[17]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D97360&amp;sa=D&amp;source=editors&amp;ust=1633325299749000&amp;usg=AOvVaw3lckIv8Fr074I9aUfTQK1G">https://reviews.llvm.org/D97360</a></span><span class="c3">, </span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D99884&amp;sa=D&amp;source=editors&amp;ust=1633325299750000&amp;usg=AOvVaw1XJ0ZTSq0gvFxGCwn6gnYe">https://reviews.llvm.org/D99884</a></span><span class="c3">&nbsp;</span></p></div><div><p class="c44"><a href="#ftnt_ref18" id="ftnt18">[18]</a><span>&nbsp;</span><span class="c47 c46"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D93853&amp;sa=D&amp;source=editors&amp;ust=1633325299750000&amp;usg=AOvVaw3WOBnpIOFlzN4HOnfe9p7f">https://reviews.llvm.org/D93853</a></span><span class="c3">&nbsp;</span></p></div><div><p class="c44"><a href="#ftnt_ref19" id="ftnt19">[19]</a><span>&nbsp;</span><span class="c46 c47"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D95026&amp;sa=D&amp;source=editors&amp;ust=1633325299751000&amp;usg=AOvVaw0D6CRi5vGpVwkv4TV5VNbf">https://reviews.llvm.org/D95026</a></span><span class="c3">&nbsp;</span></p></div><div><p class="c22"><a href="#ftnt_ref20" id="ftnt20">[20]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D95217&amp;sa=D&amp;source=editors&amp;ust=1633325299751000&amp;usg=AOvVaw1lvsknF_c8qL60BwUHkQb-">https://reviews.llvm.org/D95217</a></span></p></div><div><p class="c22"><a href="#ftnt_ref21" id="ftnt21">[21]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D99674&amp;sa=D&amp;source=editors&amp;ust=1633325299752000&amp;usg=AOvVaw3Fd7SdnPaxj_1z6xzgCkbV">https://reviews.llvm.org/D99674</a></span></p></div><div><p class="c22"><a href="#ftnt_ref22" id="ftnt22">[22]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://bugs.llvm.org/show_bug.cgi?id%3D49688&amp;sa=D&amp;source=editors&amp;ust=1633325299753000&amp;usg=AOvVaw2_oSWFbUrAW_Wtd3DQm4fV">https://bugs.llvm.org/show_bug.cgi?id=49688</a></span></p></div><div><p class="c22"><a href="#ftnt_ref23" id="ftnt23">[23]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D101191&amp;sa=D&amp;source=editors&amp;ust=1633325299753000&amp;usg=AOvVaw3BU6MET2X0u_GBIToQTUVd">https://reviews.llvm.org/D101191</a></span></p></div><div><p class="c22"><a href="#ftnt_ref24" id="ftnt24">[24]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://bugs.llvm.org/show_bug.cgi?id%3D50145&amp;sa=D&amp;source=editors&amp;ust=1633325299754000&amp;usg=AOvVaw0a1r2OO_BWDshSnPcLrtWF">https://bugs.llvm.org/show_bug.cgi?id=50145</a></span></p></div><div><p class="c22"><a href="#ftnt_ref25" id="ftnt25">[25]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://bugs.llvm.org/show_bug.cgi?id%3D49495&amp;sa=D&amp;source=editors&amp;ust=1633325299754000&amp;usg=AOvVaw20HuaKy1hMbvAnOlwRJhEP">https://bugs.llvm.org/show_bug.cgi?id=49495</a></span></p></div><div><p class="c22"><a href="#ftnt_ref26" id="ftnt26">[26]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://bugs.llvm.org/show_bug.cgi?id%3D51577&amp;sa=D&amp;source=editors&amp;ust=1633325299755000&amp;usg=AOvVaw0wx8FmK2rU3fy2eTDGjl2s">https://bugs.llvm.org/show_bug.cgi?id=51577</a></span></p></div><div><p class="c22"><a href="#ftnt_ref27" id="ftnt27">[27]</a><span class="c3">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://godbolt.org/z/Tq6bdWsT1&amp;sa=D&amp;source=editors&amp;ust=1633325299755000&amp;usg=AOvVaw3y2Wq1Rkis1FHmgY92yxkE">https://godbolt.org/z/Tq6bdWsT1</a></span><span class="c3">&nbsp;- the flag does not attach noundef to load instructions yet.</span></p></div><div><p class="c22"><a href="#ftnt_ref28" id="ftnt28">[28]</a><span class="c4 c8">&nbsp;</span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D105169&amp;sa=D&amp;source=editors&amp;ust=1633325299756000&amp;usg=AOvVaw1SZ0C4UxtYWhclVBZNeNps">https://reviews.llvm.org/D105169</a></span><span class="c3">, </span><span class="c20"><a class="c25" href="https://www.google.com/url?q=https://reviews.llvm.org/D108453&amp;sa=D&amp;source=editors&amp;ust=1633325299756000&amp;usg=AOvVaw3mrbi7wSdqv-7XlCK_dpec">https://reviews.llvm.org/D108453</a></span><span class="c3">&nbsp;</span></p></div><div><p class="c22"><a href="#ftnt_ref29" id="ftnt29">[29]</a><span class="c46">&nbsp;</span><span class="c46 c58"><a class="c25" href="https://www.google.com/url?q=https://groups.google.com/g/llvm-dev/c/sDYaYV_ZF-g/m/5Ektu6vM_0oJ&amp;sa=D&amp;source=editors&amp;ust=1633325299757000&amp;usg=AOvVaw1GEd6TjEfUvOVVRTEz2cq9">https://groups.google.com/g/llvm-dev/c/sDYaYV_ZF-g/m/5Ektu6vM_0oJ</a></span><span class="c46">&nbsp;</span></p></div>

<div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://aqjune.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</body></html>
